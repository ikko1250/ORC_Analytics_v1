# リファクタリング仕様書：熱源計算モジュールの分離

## 1. 目的

現在の`ORC_Analysis.py`内に混在している「熱源の物理特性を計算するロジック」と「ORCサイクルの性能を計算するロジック」を分離する。
これにより、コードの責務を明確にし、将来的な熱源タイプ（排ガス、水蒸気など）の追加を容易にすることを目的とする。

## 2. 変更方針

1.  熱源計算に関するロジックを、新しく作成する `ORC_analysis/heat_source.py` に集約する。
2.  `ORC_analysis/ORC_Analysis.py` は、`heat_source.py` の関数を呼び出して熱源のプロファイルを取得し、それを用いてORCサイクルの計算に専念するように修正する。

---

## 3. 新規作成ファイル

### 3.1. `ORC_analysis/heat_source.py`

熱源の物理特性を計算し、標準化されたデータ形式で返すモジュールを新設する。

```python
from dataclasses import dataclass
import CoolProp.CoolProp as CP

@dataclass
class HeatSourceProfile:
    """
    熱源の物理特性を保持するデータクラス。
    このクラスを介して、計算に必要な情報を一貫した形式で受け渡す。
    """
    m_dot: float          # 質量流量 [kg/s]
    cp: float             # 平均比熱 [J/kg/K]
    T_in: float           # 熱交換器への入口温度 [K]
    T_out_min: float      # 熱交換器からの最低出口温度 [K]
    Q_available: float    # 利用可能熱量 [W]

def get_heat_source_profile(
    T_htf_in: float,
    Vdot_htf: float,
    T_htf_out: float,
    heat_source_type: str = "liquid",
    fluid_htf: str = "Water",
    **kwargs
) -> HeatSourceProfile:
    """
    熱源の種類と条件に基づき、その物理特性プロファイルを計算して返す。
    将来的にはこの関数に "gas" や "steam" の分岐を追加していく。
    """
    if heat_source_type == "liquid":
        # 現在のORC_Analysis.pyにある液体熱源の計算ロジックをここに集約
        rho_htf = CP.PropsSI("D", "T", T_htf_in, "P", 101325, fluid_htf)
        cp_htf = CP.PropsSI("C", "T", T_htf_in, "P", 101325, fluid_htf)
        m_dot_htf = Vdot_htf * rho_htf
        
        Q_available = m_dot_htf * cp_htf * (T_htf_in - T_htf_out)

        return HeatSourceProfile(
            m_dot=m_dot_htf,
            cp=cp_htf,
            T_in=T_htf_in,
            T_out_min=T_htf_out,
            Q_available=Q_available
        )

    elif heat_source_type == "gas":
        # 将来の拡張ポイント
        raise NotImplementedError("Gas heat source calculation is not yet implemented.")
        
    elif heat_source_type == "steam":
        # 将来の拡張ポイント
        raise NotImplementedError("Steam heat source calculation is not yet implemented.")

    else:
        raise ValueError(f"Unknown heat_source_type: {heat_source_type}")
```

---

## 4. 修正対象ファイル

### 4.1. `ORC_analysis/ORC_Analysis.py`

メインの計算関数から熱源の物理量（密度、比熱など）の直接計算を削除し、`heat_source.py`の関数呼び出しに置き換える。

**修正対象関数**: `calculate_orc_performance_from_heat_source`

**修正前（イメージ）**:
```python
def calculate_orc_performance_from_heat_source(...):
    # ...
    # 熱源の物性計算が関数内に直接記述されている
    rho_htf = CP.PropsSI("D", "T", T_htf_in, "P", 101325, fluid_htf)
    cp_htf = CP.PropsSI("C", "T", T_htf_in, "P", 101325, fluid_htf)
    m_dot_htf = Vdot_htf * rho_htf
    Q_available = m_dot_htf * cp_htf * (T_htf_in - T_htf_out)
    # ...
    # Q_availableなどを使ってORCサイクルの計算が続く
    # ...
```

**修正後（実装方針）**:
```python
from .heat_source import get_heat_source_profile # 新規import

def calculate_orc_performance_from_heat_source(
    T_htf_in, Vdot_htf, T_htf_out, T_cond, eta_pump, eta_turb,
    fluid_orc="R245fa",
    fluid_htf="Water",
    heat_source_type="liquid",
    **kwargs
):
    # 1. 熱源プロファイルの取得
    # 熱源に関する計算を外部モジュールに委譲する
    heat_source = get_heat_source_profile(
        T_htf_in=T_htf_in,
        Vdot_htf=Vdot_htf,
        T_htf_out=T_htf_out,
        heat_source_type=heat_source_type,
        fluid_htf=fluid_htf,
        **kwargs
    )

    # 2. ORCサイクルの計算
    # 標準化されたheat_sourceオブジェクトから値を取得して計算を進める
    # (以降の計算ロジックは、heat_sourceオブジェクトのプロパティを使うように変更)
    # 例: Q_available = heat_source.Q_available
    # ...
```

---

## 5. 期待される効果

-   **関心の分離**: `ORC_Analysis.py`はORCサイクルの計算に、`heat_source.py`は熱源の定義にそれぞれ専念でき、コードの見通しが良くなる。
-   **拡張性の向上**: 新しい熱源（ガス、蒸気等）に対応する際、変更箇所が`heat_source.py`に限定され、既存のコアロジックへの影響を最小限に抑えられる。
-   **テストの容易性**: 熱源計算ロジックを`heat_source.py`で単体テストできるようになり、品質が向上する。

## 6. 次のステップ

1.  本仕様書に基づき、`heat_source.py`を新規作成し、`ORC_Analysis.py`を修正する。
2.  既存のテストがすべてパスすることを確認する。
3.  必要に応じて、`heat_source.py`に新しい熱源タイプの計算ロジックを`elif`ブロックとして追加開発する。
